package com.sbi.upi.merchantMode.merchant.merInitial.userTypeSelection;


import android.Manifest;
import android.annotation.SuppressLint;
import android.app.Activity;
import android.app.AlertDialog;
import android.content.Context;
import android.content.Intent;
import android.content.IntentSender;
import android.content.pm.PackageManager;
import android.graphics.Color;
import android.graphics.Paint;
import android.graphics.drawable.ColorDrawable;
import android.location.Location;
import android.location.LocationManager;
import android.net.Uri;
import android.net.wifi.ScanResult;
import android.net.wifi.WifiInfo;
import android.net.wifi.WifiManager;
import android.os.Bundle;
import android.os.Handler;
import android.provider.Settings;
import android.util.DisplayMetrics;
import android.util.Log;
import android.view.Gravity;
import android.view.LayoutInflater;
import android.view.View;
import android.view.animation.LinearInterpolator;
import android.widget.Button;
import android.widget.ImageView;
import android.widget.TextView;
import android.widget.Toast;

import com.google.android.gms.common.api.ResolvableApiException;
import com.google.android.gms.tasks.*;

import androidx.annotation.NonNull;
import androidx.core.app.ActivityCompat;
import androidx.core.content.ContextCompat;

import com.google.android.gms.location.FusedLocationProviderClient;
import com.google.android.gms.location.LocationRequest;
import com.google.android.gms.location.LocationServices;
import com.google.android.gms.location.LocationSettingsRequest;
import com.google.android.gms.location.LocationSettingsResponse;
import com.google.android.gms.location.SettingsClient;
import com.google.android.gms.tasks.Task;
import com.sbi.upi.BuildConfig;
import com.sbi.upi.R;
import com.sbi.upi.customerMode.common.AppConstants;
import com.sbi.upi.customerMode.common.BaseActivity;
import com.sbi.upi.customerMode.common.LogUtil;
import com.sbi.upi.customerMode.common.MyApplication;
import com.sbi.upi.customerMode.common.Util;
import com.sbi.upi.customerMode.common.data.local.preferences.SharedPreferenceHelper;
import com.sbi.upi.customerMode.common.data.models.response.DeviceAndAppCheckResponse;
import com.sbi.upi.customerMode.common.data.models.response.PushNotificationData;
import com.sbi.upi.customerMode.common.data.models.response.checkdevice.CheckDeviceResponse;
import com.sbi.upi.customerMode.common.dialog.DialogListener;
import com.sbi.upi.customerMode.common.dialog.DialogUtils;
import com.sbi.upi.customerMode.modules.initial.splash.SplashActivity;
import com.sbi.upi.merchantMode.merCommon.merResponse.MerCheckDeviceResponse;
import com.sbi.upi.merchantMode.merchant.login.LoginActivity;
import com.sbi.upi.merchantMode.merchant.merInitial.merSimSelection.SIMSelectionActivity;

import java.util.List;

public class Onboarding extends BaseActivity implements
        BaseActivity.PermissionListener, UserTypeSelectionContract.View, UserTypeSelectionBottomSheet.UserTypeSelectionListeners {

    //usertypeselection code
    private BaseActivity activity = null;
    private Context context = null;

    private UserTypeSelectionPresenter presenter = new UserTypeSelectionPresenter(this, this);
    private int triedCount = 0;
    private final String TAG = getClass().getSimpleName();
    private PushNotificationData pushNotificationData = null;
    private String notificationData = null;

    // Geotag
    private FusedLocationProviderClient mFusedLocationClient;
    private boolean isMerchantSelected = false;
    private final int PERMISSION_ID = 44;
    private AlertDialog.Builder builder;
    private boolean isUnsecuredSnowCone = false;
    UserTypeSelectionBottomSheet userTypeSelectionBottomSheet;
    CheckDeviceResponse checkDeviceResponse;

    boolean remembertv;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.onboarding);
        activity = this;
        context = this;
        View step1 = findViewById(R.id.step1);
        View step2 = findViewById(R.id.step2);
        View step3 = findViewById(R.id.step3);
        TextView subheading = findViewById(R.id.subheading);
        subheading.setPaintFlags(subheading.getPaintFlags() | Paint.UNDERLINE_TEXT_FLAG);
        setupStep(step1, "Registration", "Enter your mobile number to start.", true);
        setupStep(step2, "Link bank & VPA", "Connect your SBI account.", true);
        setupStep(step3, "Set Mpin", "Create unique Mpin for transaction", false);

        Button startButton = findViewById(R.id.startButton);

        userTypeSelectionBottomSheet = new UserTypeSelectionBottomSheet();
        startButton.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                showUsertypeSelectionBottomsheet();
            }
        });

        View line1to2 = findViewById(R.id.line1to2);
        View line2to3 = findViewById(R.id.line2to3);
        // Animate line 1 → 2
        line1to2.animate()
                .scaleY(1f)
                .setDuration(1500)
                .setStartDelay(1000)
                .setInterpolator(new LinearInterpolator())
                .withEndAction(() -> {
                    // Animate line 2 → 3 after 1 finishes
                   /* line2to3.animate()
                            .scaleY(1f)
                            .setDuration(1500)
                            .setInterpolator(new LinearInterpolator())
                            .start();*/
                })
                .start();


        //usertypeselectioncode
        builder = new AlertDialog.Builder(context);
        mFusedLocationClient = LocationServices.getFusedLocationProviderClient(context);
        if (getIntent().getExtras() != null) {
            checkDeviceResponse = getIntent().getExtras().getParcelable(AppConstants.UPDATE_DETAILS);
            MyApplication.checkDeviceResponse = checkDeviceResponse; // Default Cust/Mer
        }
        if (getIntent() != null && getIntent().getExtras() != null && getIntent().getExtras().get(AppConstants.NOTIFICATION_DATA) != null) {
            pushNotificationData = (PushNotificationData) getIntent().getExtras().get(AppConstants.NOTIFICATION_DATA);
            getIntent().putExtra(AppConstants.ISRECEIVER, getIntent().getExtras().getBoolean(AppConstants.ISRECEIVER)); // UI UX
        }
        //usertypecode
        tryAgainTextView.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                triedCount++;
                if (tryAgainTextView.getText() == getString(R.string.close)) {
                    finish();
                    return;
                }
                errorContentView.setVisibility(View.GONE);
                // presenter.beginCommunication();  //TODO presenter
            }
        });

        if (Util.wifiCheck(context)) {
            if (ContextCompat.checkSelfPermission(context, Manifest.permission.ACCESS_FINE_LOCATION) == PackageManager.PERMISSION_GRANTED) {
                LocationManager locationManager = (LocationManager) context.getSystemService(BaseActivity.LOCATION_SERVICE);

                if (locationManager.isProviderEnabled(LocationManager.GPS_PROVIDER)) {
                    checkUnsecuredWifi();
                } else {
                    showDialog();
                    isUnsecuredSnowCone = true;
                }
            } else {
                showDialogUnsecuredWifiLocation();
            }
        }


    }

    private void showUsertypeSelectionBottomsheet() {
        try {
            if (!userTypeSelectionBottomSheet.isAdded()) {
                userTypeSelectionBottomSheet.show(getSupportFragmentManager(), userTypeSelectionBottomSheet.getTag());
            }
        } catch (NullPointerException e) {
            LogUtil.printException(e);
        } catch (Exception e) {
            LogUtil.printException(e);
        }
    }

    private void setupStep(View stepView, String title, String desc, boolean checked) {
        TextView stepTitle = stepView.findViewById(R.id.stepTitle);
        TextView stepDesc = stepView.findViewById(R.id.stepDescription);
        ImageView checkIcon = stepView.findViewById(R.id.checkIcon);

        stepTitle.setText(title);
        stepDesc.setText(desc);
        checkIcon.setVisibility(checked ? View.VISIBLE : View.INVISIBLE);
    }


    @Override
    public boolean sbinCheck() {
        return isSbinInstalled();
    }

    @Override
    public void onNewVersionAvailable(DeviceAndAppCheckResponse deviceAndAppCheckResponse) {
        onUpdateAvailable(deviceAndAppCheckResponse);
    }

    @Override
    public void onUnReliableDevice() {
        showRootedDeviceView();
    }

    @Override
    public void onSuspeciousDevice() {
        showRootedDeviceView();
    }


    @Override
    public void showAppNotDownloadedFromPlayStore() {
        DialogUtils.showAlert(
                this,
                getResString(R.string.app_not_from_play_store),
                getResString(R.string.okay),
                new DialogListener() {
                    @Override
                    public void onPositiveClicked() {
                        killApp();
                    }

                    @Override
                    public void onNegativeClicked() {
                        // No action needed
                    }
                }
        );
    }

    // Geotag
    @Override
    public void onPermissionDenied() {
        if (isMerchantSelected) {
            showToast(R.string.need_permission_for_action);
        }
    }

    @Override
    public void goTutorialMerchant(MerCheckDeviceResponse response) {

    }

    @Override
    public void goToLoginInMerchant(String name) {
        Intent intent = new Intent(this, LoginActivity.class);
        if (pushNotificationData != null) {
            intent.putExtra(AppConstants.NOTIFICATION_DATA, pushNotificationData);
        }
        goToActivity(intent, true);
    }

    private void customerLogin() {
        checkDeviceResponse.Usertype_Selected = true;
        MyApplication.IS_SBIPAY_MERCHANT = false;
        SplashActivity.getInstance().callPresenterProceedProcess(checkDeviceResponse);
        finish();
    }

    @Override
    public void resetTryAgainCount() {
        triedCount = 0;
    }

    @Override
    public String getScreenSize() {
        DisplayMetrics dm = new DisplayMetrics();
        getWindowManager().getDefaultDisplay().getMetrics(dm);
        double x = Math.pow(dm.widthPixels / dm.xdpi, 2.0);
        double y = Math.pow(dm.heightPixels / dm.ydpi, 2.0);
        double screenInches = Math.sqrt(x + y);
        LogUtil.info("debug", "Screen inches : " + screenInches);
        screenInches = Math.round(screenInches * 10) / 10.0;
        return screenInches + "";
    }

    @Override
    public Context getContext() {
        return context;
    }

    @Override
    public Context getAppContext() {
        return context;
    }

    @Override
    public void gotoDeviceBindingActivity(MerCheckDeviceResponse merCheckDeviceResponse) {
        // TODO merchant check device
        // TODO Commented for skipping registration process
        Intent intent = new Intent(this, SIMSelectionActivity.class);
        intent.putExtra(AppConstants.UPDATE_DETAILS, merCheckDeviceResponse);
        goToActivity(intent, true);
    }

    @Override
    public void showProgressDialog() {
        /*loadingLayout.setVisibility(View.VISIBLE);
        progressBar.setIndeterminate(true);
        btn_continue.setVisibility(View.GONE);*/
    }

    @Override
    public void dismissProgressDialog() {
        //loadingLayout.setVisibility(View.GONE);
    }

    @Override
    public String getResString(int something_is_not_right) {
        return getString(something_is_not_right);
    }

    @Override
    public void showErrorScreen(int resString) {
        showErrorScreen(getString(resString));
    }

    @Override
    public void showErrorScreen(String message) {
        // TODO show error screen
        errorMessageTextView.setText(message);
        errorContentView.setVisibility(View.VISIBLE);
        if (triedCount >= 3) {
            tryAgainTextView.setText(getResString(R.string.close));
        }
    }

    private void checkUnsecuredWifi() {
        WifiManager wifiManager = (WifiManager) context.getSystemService(BaseActivity.WIFI_SERVICE);

        WifiInfo wifiInfo = wifiManager.getConnectionInfo();
        String currentSSID = wifiInfo.getSSID().substring(1, wifiInfo.getSSID().length() - 1);
        LogUtil.info("currentSSID:UserType", currentSSID);

        List<ScanResult> networkList = wifiManager.getScanResults();
        if (networkList != null) {
            for (ScanResult network : networkList) {
                String capabilities = network.capabilities;
                Log.w(TAG, network.SSID + " capabilities : " + capabilities);
                if (currentSSID.equals(network.SSID)) {
                    if (capabilities.toUpperCase().contains("WEP")) {
                        // WEP Network
                    } else if (capabilities.toUpperCase().contains("WPA") || capabilities.toUpperCase().contains("WPA2")) {
                        // WPA or WPA2 Network
                    } else {
                        // Open Network
                        showDialogUnsecuredWifi();
                        return;
                    }
                }
            }
        }
    }

    private void showDialogUnsecuredWifiLocation() {
        LayoutInflater inflater = getLayoutInflater();
        View dialogView = inflater.inflate(R.layout.dialog_unsecured_wifi_location, null);
        builder.setView(dialogView);
        AlertDialog alertDialog = builder.create();
        alertDialog.getWindow().setBackgroundDrawable(new ColorDrawable(Color.TRANSPARENT));
        alertDialog.setCancelable(false);
        alertDialog.setCanceledOnTouchOutside(false);

        Button btn_check_wifi = dialogView.findViewById(R.id.btn_check_wifi);
        Button btn_check_without_wifi = dialogView.findViewById(R.id.btn_check_without_wifi);
        Button btn_exit = dialogView.findViewById(R.id.btn_exit);

        btn_check_wifi.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                alertDialog.dismiss();
                isUnsecuredSnowCone = true;
                getLastLocation();
            }
        });

        btn_check_without_wifi.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                customShowToast();
                alertDialog.dismiss();
            }
        });

        btn_exit.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                alertDialog.dismiss();
                if (activity != null) {
                    activity.killApp();
                }
            }
        });

        alertDialog.show();
    }

    private void customShowToast() {
        LayoutInflater inflater = getLayoutInflater();
        View layout = inflater.inflate(R.layout.custom_toast, null);
        TextView text = layout.findViewById(R.id.text);
        text.setText("We are unable to determine the nature of the connected network as your\n" +
                "location access/GPS is disabled. Kindly use a secure network while using SBI Pay");

        Toast toast = new Toast(context);
        toast.setGravity(Gravity.BOTTOM, 0, 0);
        toast.setDuration(Toast.LENGTH_LONG);
        toast.setView(layout);
        toast.show();
    }

    private void showDialogUnsecuredWifi() {
        builder = new AlertDialog.Builder(context);
        LayoutInflater inflater = getLayoutInflater();
        View dialogView = inflater.inflate(R.layout.dialog_unsecured_wifi, null);
        builder.setView(dialogView);
        AlertDialog alertDialog = builder.create();
        alertDialog.getWindow().setBackgroundDrawable(new ColorDrawable(Color.TRANSPARENT));
        alertDialog.setCancelable(false);
        alertDialog.setCanceledOnTouchOutside(false);

        Button btn_yes = dialogView.findViewById(R.id.btn_yes);
        Button btn_no = dialogView.findViewById(R.id.btn_no);

        btn_yes.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                alertDialog.dismiss();
            }
        });

        btn_no.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                alertDialog.dismiss();
                if (activity != null) {
                    activity.killApp();
                }
            }
        });

        alertDialog.show();
    }

    // Geotag to get the last known location from fused location
    @SuppressLint("MissingPermission")
    private void getLastLocation() {
        // check if permissions are given
        if (checkPermissions()) {
            // Added for Mock location fix
            LocationManager manager = (LocationManager) context.getSystemService(Context.LOCATION_SERVICE);
            if (manager != null && manager.getLastKnownLocation(LocationManager.GPS_PROVIDER).isFromMockProvider()) {
                // Mock locations are/were used
                DialogUtils.showAlert(
                        activity,
                        getString(R.string.mock_location_title),
                        getString(R.string.okay),
                        "",
                        new DialogListener() {
                            @Override
                            public void onPositiveClicked() {
                                activity.finishAndRemoveTask();
                            }

                            @Override
                            public void onNegativeClicked() {
                                // No action needed
                            }
                        }
                );
            } else {
                // check if location is enabled
                if (isLocationEnabled()) {
                    activity.showToast("Please wait while we get your current location");
                    // getting last location from FusedLocationClient
                    mFusedLocationClient.getLastLocation().addOnCompleteListener(task -> {
                        Location location = task.getResult();
                        if (location == null) {
                            requestNewLocationData();
                        } else {
                            requestNewLocationData();
                            // Handle location data here
                        }
                    });
                } else {
                    if (isUnsecuredSnowCone) {
                        showDialog();
                        customShowToast();
                    } else {
                        if (!isMerchantSelected) {
                            if (!SharedPreferenceHelper.getInstance().isGpsPermissionForCustomer()) {
                                SharedPreferenceHelper.getInstance().setGpsPermissionForCustomer();
                                showDialog();
                            } else {
                                // saved count value to shared preferences
                                Util.setLocationParameters(activity, "", true);
                                customerLogin();
                            }
                        } else if (isMerchantSelected) {
                            showDialog();  // for check 04-01-2023
                        }
                    }
                }
            }
        } else {
            // if permissions aren't available, request for permissions
            requestPermissions();
        }
    }

    // Geotag to get the new location
    @SuppressLint("MissingPermission")
    private void requestNewLocationData() {
        mFusedLocationClient = LocationServices.getFusedLocationProviderClient(this);
        mFusedLocationClient.getCurrentLocation(LocationRequest.PRIORITY_HIGH_ACCURACY, new CancellationToken() {
            @Override
            public CancellationToken onCanceledRequested(OnTokenCanceledListener onTokenCanceledListener) {
                return new CancellationTokenSource().getToken();
            }

            @Override
            public boolean isCancellationRequested() {
                return false;
            }
        }).addOnSuccessListener(location -> {
            if (location == null) {
                Toast.makeText(context, "Cannot get location.", Toast.LENGTH_SHORT).show();
                if (!isMerchantSelected) {
                    // customer redirect to location setting page only once.
                    Util.setLocationParameters(activity, "", true);
                    customerLogin();
                }
            } else {
                String geoLocation = location.getLatitude() + "," + location.getLongitude();
                LogUtil.info("geoLocation", geoLocation);
                if (!geoLocation.equals("0.0,0.0")) {
                    Util.setLocationParameters(activity, geoLocation, false);
                    if (isLocationEnabled()) {
                        if (isUnsecuredSnowCone) {
                            checkUnsecuredWifi();
                            isUnsecuredSnowCone = false;
                        } else {
                            if (isMerchantSelected) {
                                MyApplication.IS_SBIPAY_MERCHANT = true;
                                UserTypeSelectionPresenter presenter = new UserTypeSelectionPresenter(context, this);
                                presenter.beginCommunication();
                                //btn_continue.setEnabled(false);
                            } else {
                                customerLogin();
                            }
                        }
                    }
                }
            }
        });
    }

    // Geotag method to check for permissions
    private boolean checkPermissions() {
        return ActivityCompat.checkSelfPermission(context, Manifest.permission.ACCESS_FINE_LOCATION) == PackageManager.PERMISSION_GRANTED;
    }

    // Geotag method to request for permissions
    private void requestPermissions() {
        ActivityCompat.requestPermissions(activity, new String[]{Manifest.permission.ACCESS_FINE_LOCATION}, PERMISSION_ID);
    }

    // Geotag method to check if location is enabled or not
    private boolean isLocationEnabled() {
        LocationManager locationManager = (LocationManager) activity.getSystemService(BaseActivity.LOCATION_SERVICE);
        return locationManager.isProviderEnabled(LocationManager.GPS_PROVIDER) || locationManager.isProviderEnabled(LocationManager.NETWORK_PROVIDER);
    }

    // Geotag
    @Override
    public void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) {
        super.onRequestPermissionsResult(requestCode, permissions, grantResults);
        if (requestCode == PERMISSION_ID) {
            if (grantResults.length > 0 && grantResults[0] == PackageManager.PERMISSION_GRANTED) {
                getLastLocation();
            } else {
                // if denied
                if (isUnsecuredSnowCone) {
                    customShowToast();
                    isUnsecuredSnowCone = false;
                } else {
                    if (!isMerchantSelected) {
                        // customer redirect to location setting page only once.
                        Util.setLocationParameters(activity, "", true);
                        customerLogin();
                    } else if (isMerchantSelected) {
                        // permission page location
                        redirectToAppPermissionDialog();
                    }
                }
            }
        }
    }

    // Geotag to allow location permission if location is disabled
    public void showDialog() {
        builder = new AlertDialog.Builder(context);
        builder.setMessage("Kindly Allow GPS to Access Location")
                .setCancelable(false)
                .setPositiveButton("Enable GPS permission", (dialog, id) -> {
                    turnOnGPS();
                    dialog.cancel();
                })
                .setNegativeButton("Do it later", (dialog, id) -> {
                    dialog.cancel();
                    if (isUnsecuredSnowCone) {
                        customShowToast();
                        isUnsecuredSnowCone = false;
                    } else {
                        if (!isMerchantSelected) {
                            Util.setLocationParameters(activity, "", true);
                            customerLogin();
                        }
                    }
                });
        // Creating dialog box
        AlertDialog alert = builder.create();
        alert.setTitle("Permission");
        alert.show();
    }


    // Geotag redirect to setting page if location is denied
    private void redirectToAppPermissionDialog() {
        builder = new AlertDialog.Builder(context);
        builder.setMessage("Location permissions are mandatory to access business Tab")
                .setTitle("Permission")
                .setCancelable(false)
                .setPositiveButton("Allow", (dialog, id) -> {
                    startActivity(new Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS, Uri.parse("package:" + BuildConfig.APPLICATION_ID)));
                })
                .setNegativeButton("Deny", (dialog, id) -> dialog.cancel());

        // Creating dialog box
        AlertDialog alert = builder.create();
        alert.setTitle("Permission");
        alert.show();
    }

    @Override
    public void onActivityResult(int requestCode, int resultCode, Intent data) {
        super.onActivityResult(requestCode, resultCode, data);
        try {
            if (requestCode == AppConstants.REQUEST_INTENT_CALL && resultCode == Activity.RESULT_OK && data != null) {
                activity.setResult(data.getExtras());
            } else if (requestCode == AppConstants.REQUEST_INTENT_CALL && resultCode == Activity.RESULT_CANCELED) {
                activity.finish();
            }
            // Geotag location callback if permission is declined or approved
            if (requestCode == 12345) {
                if (resultCode == BaseActivity.RESULT_OK) {
                    activity.showToast("GPS opened");
                    if (isUnsecuredSnowCone) {
                        checkUnsecuredWifi();
                        isUnsecuredSnowCone = false;
                    }
                    // if user allows to open GPS, proceed
                    // getLastLocation();
                } else if (resultCode == BaseActivity.RESULT_CANCELED) {
                    activity.showToast("Refused to open GPS");
                    if (isUnsecuredSnowCone) {
                        customShowToast();
                    } else {
                        if (!isMerchantSelected) {
                            Util.setLocationParameters(activity, "", true);
                            customerLogin();
                        }
                    }
                }
            }
        } catch (Exception e) {
            activity.finish();
        }
    }

    // Geotag
    private void turnOnGPS() {
        LocationRequest request = LocationRequest.create();
        request.setInterval(2000);
        request.setPriority(LocationRequest.PRIORITY_HIGH_ACCURACY);

        LocationSettingsRequest.Builder builder = new LocationSettingsRequest.Builder().addLocationRequest(request);
        SettingsClient client = LocationServices.getSettingsClient(this);
        Task<LocationSettingsResponse> task = client.checkLocationSettings(builder.build());
        task.addOnFailureListener(it -> {
            if (it instanceof ResolvableApiException) {
                try {
                    ((ResolvableApiException) it).startResolutionForResult(this, 12345);
                } catch (IntentSender.SendIntentException sendEx) {
                    // Handle the exception
                }
            }
        }).addOnSuccessListener(locationSettingsResponse -> {
            // Here GPS is already enabled
            LogUtil.info("gpsEnabled", "enabled");
            if (isUnsecuredSnowCone) {
                checkUnsecuredWifi();
                isUnsecuredSnowCone = false;
            }
        });
    }


    @Override
    public void onSubmit(boolean isRememberMe, String isCustomerOrMer) {

        remembertv = isRememberMe;

        if (isCustomerOrMer.equalsIgnoreCase("merchant")) {
            isMerchantSelected = true;
        } else {
            isMerchantSelected = false;
        }

        if (remembertv) {
            SharedPreferenceHelper.getInstance().setRememberMe(true);
            SharedPreferenceHelper.getInstance().setDefaultUserSelectionEnable(true);

            if (isMerchantSelected) {
                SharedPreferenceHelper.getInstance().setdefaultCustomerOrMerchant("merchant");
                SharedPreferenceHelper.getInstance().setDefaultUserSelectionEnable(true);
            } else {
                SharedPreferenceHelper.getInstance().setdefaultCustomerOrMerchant("customer");
                SharedPreferenceHelper.getInstance().setDefaultUserSelectionEnable(true);
            }
        } else {
            SharedPreferenceHelper.getInstance().setRememberMe(false);
            SharedPreferenceHelper.getInstance().setDefaultUserSelectionEnable(false);
        }

        // Added to prevent double click
        // btn_continue.setEnabled(false);
        new Handler().postDelayed(() -> {
            //btn_continue.setEnabled(true);
            LogUtil.info("buttonstate", "resend1");
        }, 3000); // Set time as per your requirement

        if (isMerchantSelected) {
            isMerchantSelected = true;
            // New implementation by Ruchir GEOTAG 02-01-2023
            getLastLocation();
        } else {
            isMerchantSelected = false;
            // New implementation by Ruchir GEOTAG 02-01-2023
            getLastLocation();
        }
    }
}
